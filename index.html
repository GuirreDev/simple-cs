<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Simple CS: Competitive</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        /* ESTILOS GENERALES */
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Consolas', monospace; color: white; user-select: none; }
        #game-container { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
        canvas { background: #1a1a1a; box-shadow: 0 0 0 2px #333; }

        /* UI OVERLAYS (MENÚS) */
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.92); z-index: 100; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        .hidden { display: none !important; }

        h1 { font-size: 64px; color: #f0ad4e; margin-bottom: 20px; text-transform: uppercase; letter-spacing: 5px; }
        .box { background: #222; padding: 40px; border: 1px solid #444; border-radius: 8px; text-align: center; min-width: 300px; }
        
        button { background: #f0ad4e; color: #000; border: none; padding: 15px 30px; font-size: 18px; font-weight: bold; cursor: pointer; width: 100%; margin: 10px 0; transition: 0.2s; }
        button:hover { background: #ffc107; transform: scale(1.02); }
        button.secondary { background: #444; color: #fff; }
        button.secondary:hover { background: #555; }
        
        input { width: 90%; padding: 15px; text-align: center; background: #111; border: 1px solid #555; color: white; font-size: 16px; margin-bottom: 15px; }
        
        .code-display { font-size: 24px; color: #0f0; background: #000; padding: 10px; border: 1px dashed #0f0; margin: 15px 0; cursor: pointer; }

        /* HUD (INTERFAZ DE JUEGO) */
        #hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .top-bar { display: flex; justify-content: space-between; padding: 20px; font-size: 28px; font-weight: bold; text-shadow: 2px 2px 0 #000; }
        .score-blue { color: #5bc0de; }
        .score-red { color: #d9534f; }
        .timer { color: #fff; background: rgba(0,0,0,0.5); padding: 5px 15px; border-radius: 5px; }
        
        .bottom-left { position: absolute; bottom: 20px; left: 20px; text-align: left; }
        .weapon-card { background: rgba(0,0,0,0.7); padding: 15px; border-left: 5px solid #f0ad4e; }
        .w-name { font-size: 14px; color: #aaa; text-transform: uppercase; }
        .w-ammo { font-size: 32px; color: #fff; }
        .round-info { position: absolute; top: 80px; left: 50%; transform: translateX(-50%); font-size: 14px; color: #888; }
    </style>
</head>
<body>

    <div id="menu" class="overlay">
        <h1>SIMPLE CS</h1>
        <div class="box" id="menu-start">
            <button onclick="setupHost()">CREAR PARTIDA (HOST)</button>
            <button class="secondary" onclick="showJoin()">UNIRSE A PARTIDA</button>
        </div>
        
        <div class="box hidden" id="menu-host">
            <p>Tu código de partida:</p>
            <div class="code-display" id="my-id" onclick="copyId()">Cargando ID...</div>
            <p style="font-size: 12px; color: #aaa;">Comparte este código con tu amigo.</p>
            <p id="status-host" style="color: yellow; margin-top: 10px;">Esperando jugador...</p>
        </div>

        <div class="box hidden" id="menu-join">
            <input type="text" id="host-id" placeholder="Pegar código aquí">
            <button onclick="joinGame()">CONECTAR</button>
            <button class="secondary" onclick="location.reload()">VOLVER</button>
        </div>
    </div>

    <div id="game-over" class="overlay hidden">
        <h1 id="winner-msg">VICTORIA</h1>
        <button onclick="location.reload()" style="width: 200px;">MENÚ PRINCIPAL</button>
    </div>

    <div id="game-container">
        <canvas id="canvas"></canvas>
        <div id="hud" class="hidden">
            <div class="top-bar">
                <div class="score-blue" id="score-b">0</div>
                <div class="timer" id="timer">02:30</div>
                <div class="score-red" id="score-r">0</div>
            </div>
            <div class="round-info" id="round-display">RONDA 1 / 7</div>
            <div class="bottom-left">
                <div class="weapon-card">
                    <div class="w-name" id="w-name">PISTOLA</div>
                    <div class="w-ammo" id="w-ammo">12 / ∞</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // === CONFIGURACIÓN ===
        const CONFIG = {
            width: 1024, height: 768,
            walkSpeed: 3, runSpeed: 5,
            roundTime: 150, // Segundos
            winScore: 7
        };

        // === ESTADO DEL JUEGO ===
        let canvas = document.getElementById('canvas');
        let ctx = canvas.getContext('2d');
        canvas.width = CONFIG.width;
        canvas.height = CONFIG.height;

        let isHost = false;
        let peer, conn;
        
        // Estado sincronizado (La verdad absoluta está en el Host)
        let state = {
            active: false,
            round: 1,
            timer: CONFIG.roundTime,
            scores: { blue: 0, red: 0 },
            players: [], // 0:Host, 1:Client, 2,3:BotsBlue, 4,5:BotsRed
            bullets: [],
            walls: []
        };
        
        // Input local
        let input = {
            keys: { w:0, a:0, s:0, d:0, shift:0 },
            mouse: { x:0, y:0, down:0 },
            weapon: 1 // 0:SMG, 1:Pistol, 2:Knife
        };

        // Cliente: copia del estado para renderizar
        let clientState = null; 

        // === DEFINICIÓN DE OBJETOS ===
        const WEAPONS = [
            { name: 'SUBFUSIL', rate: 100, dmg: 10, auto: true, ammo: 30, unlock: 4 }, // ID 0
            { name: 'GLOCK', rate: 300, dmg: 18, auto: false, ammo: 12, unlock: 1 },  // ID 1
            { name: 'CUCHILLO', rate: 500, dmg: 45, auto: false, ammo: -1, unlock: 1 } // ID 2
        ];

        // === RED (PEERJS) ===
        function setupHost() {
            document.getElementById('menu-start').classList.add('hidden');
            document.getElementById('menu-host').classList.remove('hidden');
            
            peer = new Peer();
            peer.on('open', id => document.getElementById('my-id').innerText = id);
            peer.on('connection', c => {
                conn = c;
                isHost = true;
                document.getElementById('status-host').innerText = "¡Jugador conectado! Iniciando...";
                setTimeout(startGameHost, 1000);
            });
        }

        function showJoin() {
            document.getElementById('menu-start').classList.add('hidden');
            document.getElementById('menu-join').classList.remove('hidden');
        }

        function joinGame() {
            let id = document.getElementById('host-id').value;
            if(!id) return;
            peer = new Peer();
            peer.on('open', myId => {
                conn = peer.connect(id);
                isHost = false;
                conn.on('open', () => {
                    document.getElementById('menu').classList.add('hidden');
                    document.getElementById('hud').classList.remove('hidden');
                    startGameClient();
                });
            });
        }

        function copyId() {
            navigator.clipboard.writeText(document.getElementById('my-id').innerText);
            alert("ID Copiado");
        }

        // === LÓGICA DEL HOST ===
        function startGameHost() {
            document.getElementById('menu').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            
            // Definir Mapa (Paredes)
            state.walls = [
                {x:0,y:0,w:1024,h:20}, {x:0,y:748,w:1024,h:20}, // Bordes H
                {x:0,y:0,w:20,h:768}, {x:1004,y:0,w:20,h:768},  // Bordes V
                {x:200,y:200,w:20,h:300}, {x:200,y:200,w:300,h:20}, // Estructura A
                {x:700,y:400,w:20,h:200}, {x:600,y:600,w:120,h:20}, // Estructura B
                {x:450,y:350,w:100,h:100} // Caja Central
            ];

            startRound();

            // Loop principal del Host (60 FPS)
            setInterval(updateHost, 1000/60);
            // Timer del juego (1 segundo)
            setInterval(() => {
                if(state.active && state.timer > 0) state.timer--;
                if(state.active && state.timer <= 0) endRound('timeout');
            }, 1000);

            // Escuchar inputs del cliente
            conn.on('data', data => {
                if(data.type === 'input') handleInput(1, data.payload);
            });
        }

        function startRound() {
            state.timer = CONFIG.roundTime;
            state.active = true;
            state.bullets = [];
            
            // Reiniciar jugadores
            state.players = [
                createPlayer(0, 'blue', 100, 384, false), // Host
                createPlayer(1, 'red', 900, 384, false),  // Cliente
                createPlayer(2, 'blue', 80, 300, true),   // Bot Blue 1
                createPlayer(3, 'blue', 80, 460, true),   // Bot Blue 2
                createPlayer(4, 'red', 920, 300, true),   // Bot Red 1
                createPlayer(5, 'red', 920, 460, true)    // Bot Red 2
            ];
        }

        function createPlayer(id, team, x, y, isBot) {
            return {
                id: id, team: team, x: x, y: y, angle: 0,
                hp: 100, alive: true, isBot: isBot,
                weapon: 1, ammo: 12, lastShot: 0
            };
        }

        function updateHost() {
            if(!state.active) return;

            // 1. Procesar Input Host (Jugador 0)
            handleInput(0, input);

            // 2. IA de Bots
            state.players.forEach(p => {
                if(p.isBot && p.alive) updateBot(p);
            });

            // 3. Físicas de Balas
            state.bullets.forEach((b, i) => {
                b.x += b.vx; b.y += b.vy;
                
                // Colisión Paredes
                let hitWall = state.walls.some(w => rectCol(b.x, b.y, 4, 4, w.x, w.y, w.w, w.h));
                if(hitWall || b.x<0 || b.x>CONFIG.width || b.y<0 || b.y>CONFIG.height) {
                    state.bullets.splice(i, 1);
                    return;
                }

                // Colisión Jugadores
                state.players.forEach(p => {
                    if(p.alive && p.team !== b.team) {
                        let dist = Math.hypot(p.x - b.x, p.y - b.y);
                        if(dist < 15) {
                            p.hp -= b.dmg;
                            if(p.hp <= 0) { p.alive = false; checkWin(); }
                            state.bullets.splice(i, 1);
                        }
                    }
                });
            });

            // 4. Enviar estado al cliente
            if(conn && conn.open) {
                conn.send({ type: 'state', payload: state });
            }

            // 5. Renderizar Host
            render(state, 0);
            updateHUD(state, 0);
        }

        function handleInput(pid, inp) {
            let p = state.players[pid];
            if(!p || !p.alive) return;

            // Restricción de ronda para armas
            let wId = inp.weapon;
            if(state.round < 4 && wId === 0) wId = 1; // Forzar pistola si intenta usar subfusil antes de ronda 4
            p.weapon = wId;

            // Movimiento
            let speed = inp.keys.shift ? CONFIG.runSpeed : CONFIG.walkSpeed;
            let dx = 0, dy = 0;
            if(inp.keys.w) dy -= speed;
            if(inp.keys.s) dy += speed;
            if(inp.keys.a) dx -= speed;
            if(inp.keys.d) dx += speed;

            // Colisiones simples con paredes
            if(!wallCol(p.x + dx, p.y)) p.x += dx;
            if(!wallCol(p.x, p.y + dy)) p.y += dy;

            p.angle = inp.mouse.angle; // Se recibe ya calculado o local
            if(pid === 0) p.angle = Math.atan2(inp.mouse.y - p.y, inp.mouse.x - p.x);

            // Disparo
            if(inp.mouse.down) tryShoot(p);
        }

        function updateBot(bot) {
            // Buscar enemigo más cercano
            let target = null;
            let minDist = 9999;
            state.players.forEach(p => {
                if(p.team !== bot.team && p.alive) {
                    let d = Math.hypot(p.x - bot.x, p.y - bot.y);
                    if(d < minDist) { minDist = d; target = p; }
                }
            });

            if(target) {
                // Calcular ángulo
                let angle = Math.atan2(target.y - bot.y, target.x - bot.x);
                bot.angle = angle;
                
                // Moverse si está lejos
                if(minDist > 250) {
                    let mx = Math.cos(angle) * 2;
                    let my = Math.sin(angle) * 2;
                    if(!wallCol(bot.x + mx, bot.y)) bot.x += mx;
                    if(!wallCol(bot.x, bot.y + my)) bot.y += my;
                }

                // Disparar
                if(minDist < 400 && Math.random() < 0.03) tryShoot(bot);
            }
        }

        function tryShoot(p) {
            let w = WEAPONS[p.weapon];
            let now = Date.now();
            
            // Cooldown y Munición
            if(now - p.lastShot < w.rate) return;
            if(w.ammo !== -1 && p.ammo <= 0) return;

            p.lastShot = now;
            if(w.ammo !== -1) p.ammo--;

            // Crear bala
            if(p.weapon === 2) { 
                // Melee (no implementado visualmente complejo, solo rango corto)
            } else {
                let spread = (Math.random() - 0.5) * 0.1;
                state.bullets.push({
                    x: p.x, y: p.y,
                    vx: Math.cos(p.angle + spread) * 12,
                    vy: Math.sin(p.angle + spread) * 12,
                    team: p.team, dmg: w.dmg
                });
            }
        }

        function wallCol(x, y) {
            return state.walls.some(w => x > w.x && x < w.x + w.w && y > w.y && y < w.y + w.h);
        }
        function rectCol(x1, y1, w1, h1, x2, y2, w2, h2) {
            return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
        }

        function checkWin() {
            let blueAlive = state.players.filter(p => p.team === 'blue' && p.alive).length;
            let redAlive = state.players.filter(p => p.team === 'red' && p.alive).length;

            if(blueAlive === 0) endRound('red');
            else if(redAlive === 0) endRound('blue');
        }

        function endRound(winner) {
            state.active = false;
            if(winner === 'blue') state.scores.blue++;
            else if(winner === 'red') state.scores.red++;
            
            // Fin de Partida
            if(state.scores.blue >= CONFIG.winScore || state.scores.red >= CONFIG.winScore) {
                setTimeout(() => {
                    if(conn) conn.send({type: 'gameover', winner: winner});
                    showGameOver(winner === 'blue' ? 'EQUIPO AZUL' : 'EQUIPO ROJO');
                }, 1000);
            } else {
                state.round++;
                setTimeout(startRound, 3000); // 3 seg para siguiente ronda
            }
        }

        // === LÓGICA DEL CLIENTE ===
        function startGameClient() {
            loopClient();
            conn.on('data', data => {
                if(data.type === 'state') {
                    clientState = data.payload;
                } else if (data.type === 'gameover') {
                    showGameOver(data.winner === 'red' ? 'EQUIPO ROJO' : 'EQUIPO AZUL');
                }
            });
        }

        function loopClient() {
            if(clientState) {
                render(clientState, 1);
                updateHUD(clientState, 1);
            }
            
            // Enviar Inputs
            let rect = canvas.getBoundingClientRect();
            let mouseAngle = Math.atan2(input.mouse.y - (clientState?.players[1]?.y || 0), input.mouse.x - (clientState?.players[1]?.x || 0));

            if(conn && conn.open) {
                conn.send({
                    type: 'input',
                    payload: {
                        keys: input.keys,
                        mouse: { x: input.mouse.x, y: input.mouse.y, angle: mouseAngle, down: input.mouse.down },
                        weapon: input.weapon
                    }
                });
            }
            requestAnimationFrame(loopClient);
        }

        // === RENDERIZADO (COMÚN) ===
        function render(st, myId) {
            // Fondo
            ctx.fillStyle = '#222';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Paredes
            ctx.fillStyle = '#555';
            st.walls.forEach(w => {
                ctx.fillRect(w.x, w.y, w.w, w.h);
                ctx.strokeStyle = '#000';
                ctx.strokeRect(w.x, w.y, w.w, w.h);
            });

            // Balas
            ctx.fillStyle = '#ff0';
            st.bullets.forEach(b => {
                ctx.beginPath(); ctx.arc(b.x, b.y, 3, 0, Math.PI*2); ctx.fill();
            });

            // Jugadores
            st.players.forEach(p => {
                if(!p.alive) {
                    // Cadáver
                    ctx.fillStyle = '#330000';
                    ctx.beginPath(); ctx.arc(p.x, p.y, 10, 0, Math.PI*2); ctx.fill();
                    return;
                }

                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.angle);
                
                // Color Equipo
                ctx.fillStyle = p.team === 'blue' ? '#5bc0de' : '#d9534f';
                // Indicador "YO"
                if(p.id === myId) ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
                
                // Cuerpo
                ctx.beginPath(); ctx.arc(0, 0, 14, 0, Math.PI*2); ctx.fill();
                if(p.id === myId) ctx.stroke();

                // Arma
                ctx.fillStyle = '#eee';
                ctx.fillRect(5, -2, 20, 4); 

                ctx.restore();
            });
        }

        function updateHUD(st, myId) {
            document.getElementById('score-b').innerText = st.scores.blue;
            document.getElementById('score-r').innerText = st.scores.red;
            document.getElementById('round-display').innerText = `RONDA ${st.round} / ${CONFIG.winScore}`;
            
            let m = Math.floor(st.timer/60);
            let s = st.timer%60;
            document.getElementById('timer').innerText = `${m}:${s<10?'0'+s:s}`;

            let me = st.players[myId];
            if(me) {
                let w = WEAPONS[me.weapon];
                document.getElementById('w-name').innerText = w.name;
                document.getElementById('w-ammo').innerText = w.ammo === -1 ? '∞' : me.ammo;
            }
        }

        function showGameOver(txt) {
            document.getElementById('game-over').classList.remove('hidden');
            document.getElementById('winner-msg').innerText = txt + " GANA";
        }

        // === INPUT LISTENERS ===
        window.addEventListener('keydown', e => {
            let k = e.key.toLowerCase();
            if(k in input.keys) input.keys[k] = 1;
            if(k === 'shift') input.keys.shift = 1;
            if(k === '1') input.weapon = 0;
            if(k === '2') input.weapon = 1;
            if(k === '3') input.weapon = 2;
        });
        window.addEventListener('keyup', e => {
            let k = e.key.toLowerCase();
            if(k in input.keys) input.keys[k] = 0;
            if(k === 'shift') input.keys.shift = 0;
        });
        window.addEventListener('mousemove', e => {
            let r = canvas.getBoundingClientRect();
            input.mouse.x = e.clientX - r.left;
            input.mouse.y = e.clientY - r.top;
        });
        window.addEventListener('mousedown', () => input.mouse.down = 1);
        window.addEventListener('mouseup', () => input.mouse.down = 0);

    </script>
</body>
</html>
