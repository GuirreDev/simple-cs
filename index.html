<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Simple CS: Online - Por Aguirre</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #0a0a0a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: white; user-select: none; }
        #game-wrapper { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; background: radial-gradient(circle, #1a1a1a 0%, #000000 100%); }
        canvas { box-shadow: 0 0 50px rgba(0,0,0,0.8); border-radius: 4px; cursor: crosshair; }
        
        /* UI LAYERS */
        .ui-screen { position: absolute; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background: rgba(0,0,0,0.85); backdrop-filter: blur(5px); z-index: 10; transition: opacity 0.3s; }
        .hidden { display: none !important; opacity: 0; pointer-events: none; }
        
        /* TEXTOS Y BOTONES */
        h1 { font-size: 72px; margin: 0 0 20px 0; background: linear-gradient(45deg, #ff9900, #ffcc00); -webkit-background-clip: text; -webkit-text-fill-color: transparent; letter-spacing: 2px; text-transform: uppercase; font-weight: 900; }
        .panel { background: rgba(255,255,255,0.05); padding: 30px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); text-align: center; max-width: 500px; width: 90%; }
        input { padding: 12px; font-size: 18px; width: 70%; background: #222; border: 1px solid #444; color: white; border-radius: 4px; text-align: center; margin-bottom: 15px; font-family: monospace; letter-spacing: 1px; }
        input:focus { outline: none; border-color: #ff9900; }
        .btn { background: linear-gradient(to bottom, #444, #333); color: white; border: 1px solid #555; padding: 12px 30px; font-size: 18px; cursor: pointer; margin: 10px; border-radius: 6px; font-weight: bold; transition: all 0.2s; min-width: 150px; }
        .btn:hover { background: #ff9900; color: black; border-color: #ff9900; transform: translateY(-2px); box-shadow: 0 5px 15px rgba(255, 153, 0, 0.3); }
        .btn-secondary { background: transparent; border: 1px solid #444; }
        
        /* HUD */
        #hud { pointer-events: none; width: 1024px; height: 768px; position: absolute; }
        #top-bar { display: flex; justify-content: space-between; padding: 15px 25px; align-items: flex-start; }
        .score-box { background: rgba(0,0,0,0.7); padding: 5px 15px; border-radius: 4px; border-top: 2px solid #ff9900; font-size: 24px; font-weight: bold; font-family: monospace; display: flex; gap: 20px; }
        .team-blue { color: #4facfe; } .team-red { color: #ff5858; }
        #timer { font-size: 28px; color: white; font-weight: bold; text-shadow: 0 2px 4px black; }
        
        #bottom-bar { position: absolute; bottom: 20px; left: 20px; display: flex; align-items: center; gap: 15px; }
        .weapon-card { background: rgba(0,0,0,0.7); padding: 10px 20px; border-radius: 4px; border-left: 3px solid #ff9900; }
        .weapon-name { font-size: 14px; color: #888; text-transform: uppercase; letter-spacing: 1px; }
        .ammo-count { font-size: 24px; font-weight: bold; font-family: monospace; }
        
        .waiting-text { font-size: 14px; color: #aaa; margin-top: 10px; font-family: monospace; background: #111; padding: 8px; border-radius: 4px; cursor: pointer; }
        .waiting-text:hover { background: #222; color: #fff; }
    </style>
</head>
<body>

    <div id="game-wrapper">
        <canvas id="gameCanvas"></canvas>
        <div id="hud" class="hidden">
            <div id="top-bar">
                <div class="score-box"><span class="team-blue" id="score-blue">0</span> - <span class="team-red" id="score-red">0</span></div>
                <div id="timer">02:30</div>
            </div>
            <div id="bottom-bar">
                <div class="weapon-card">
                    <div class="weapon-name" id="weapon-name">GLOCK</div>
                    <div class="ammo-count" id="ammo-count">12 / ∞</div>
                </div>
            </div>
        </div>
    </div>

    <div id="menu-screen" class="ui-screen">
        <h1>Simple CS</h1>
        <div class="panel">
            <h3>Multijugador P2P</h3>
            <p style="color:#888; font-size:14px; margin-bottom: 20px;">
                Un jugador debe crear la partida y compartir el ID.<br>
                Usa <b>Shift</b> para correr.
            </p>
            
            <div id="initial-actions">
                <button class="btn" onclick="setupHost()">CREAR PARTIDA</button>
                <button class="btn btn-secondary" onclick="showJoinMenu()">UNIRSE A PARTIDA</button>
            </div>

            <div id="host-panel" class="hidden">
                <p>Tu ID de partida:</p>
                <div class="waiting-text" id="my-peer-id" onclick="copyToClipboard()">Generando ID...</div>
                <p style="font-size: 12px; color: #666;">Copia este ID y envíalo a tu amigo. Esperando conexión...</p>
                <button class="btn btn-secondary" onclick="resetMenu()">CANCELAR</button>
            </div>

            <div id="join-panel" class="hidden">
                <input type="text" id="host-id-input" placeholder="Pega el ID aquí">
                <br>
                <button class="btn" onclick="joinGame()">CONECTAR</button>
                <button class="btn btn-secondary" onclick="resetMenu()">ATRÁS</button>
            </div>
        </div>
        <div style="margin-top: 30px; font-size: 12px; color: #444;">Desarrollado por Aguirre | Powered by PeerJS</div>
    </div>

    <div id="end-screen" class="ui-screen hidden">
        <h1 id="winner-text">VICTORIA</h1>
        <button class="btn" onclick="location.reload()">VOLVER AL MENÚ</button>
    </div>

    <script>
        // === CONFIGURACIÓN GLOBAL ===
        const CONFIG = {
            width: 1024,
            height: 768,
            maxRounds: 7,
            roundTime: 150,
            walkSpeed: 2.5,
            runSpeed: 4.2 // Velocidad al presionar Shift
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = CONFIG.width;
        canvas.height = CONFIG.height;

        // === ESTADO DEL JUEGO ===
        let isHost = false;
        let peer = null;
        let conn = null;
        let myId = null;
        
        // Input local
        const input = {
            keys: { w:false, a:false, s:false, d:false, shift:false, r:false },
            mouse: { x:0, y:0, down:false },
            weaponIdx: 1 // 0: SMG, 1: Glock, 2: Knife
        };

        // Estado sincronizado (La "Verdad" del juego)
        let gameState = {
            active: false,
            timer: CONFIG.roundTime,
            round: 1,
            score: { blue: 0, red: 0 },
            walls: [],
            players: [], // [0]=Host(Blue), [1]=Client(Red), [2,3]=BlueBots, [4,5]=RedBots
            bullets: [],
            effects: [] // Sangre, chispas
        };

        // Cliente: Predicción y suavizado
        let clientLocalPlayer = null; 

        // === CLASES ===
        class Player {
            constructor(id, team, x, y, isBot) {
                this.id = id;
                this.team = team;
                this.x = x;
                this.y = y;
                this.angle = 0;
                this.hp = 100;
                this.alive = true;
                this.isBot = isBot;
                this.currentWeapon = 1;
                this.lastShot = 0;
                this.ammo = 12; // Glock por defecto
                
                // Definición de armas
                this.weapons = {
                    0: { name: 'MP5-SD', delay: 100, dmg: 11, ammo: 30, auto: true },
                    1: { name: 'Glock-18', delay: 250, dmg: 16, ammo: 12, auto: false },
                    2: { name: 'Karambit', delay: 500, dmg: 45, ammo: null, auto: false }
                };
            }
        }

        // === RED Y PEERJS ===
        function setupHost() {
            document.getElementById('initial-actions').classList.add('hidden');
            document.getElementById('host-panel').classList.remove('hidden');
            
            peer = new Peer(); // PeerJS cloud server por defecto
            
            peer.on('open', (id) => {
                myId = id;
                document.getElementById('my-peer-id').innerText = id;
            });

            peer.on('connection', (c) => {
                conn = c;
                isHost = true;
                console.log("Cliente conectado!");
                setupConnectionEvents();
                initGame();
            });
        }

        function showJoinMenu() {
            document.getElementById('initial-actions').classList.add('hidden');
            document.getElementById('join-panel').classList.remove('hidden');
        }

        function joinGame() {
            const hostId = document.getElementById('host-id-input').value;
            if(!hostId) return;

            peer = new Peer();
            peer.on('open', (id) => {
                conn = peer.connect(hostId);
                isHost = false;
                setupConnectionEvents();
            });
        }

        function setupConnectionEvents() {
            // Ocultar menú
            document.getElementById('menu-screen').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');

            conn.on('data', (data) => {
                if (isHost) {
                    // Host recibe INPUTS del cliente
                    if (data.type === 'INPUT') {
                        handleClientInput(data.payload);
                    }
                } else {
                    // Cliente recibe ESTADO del juego
                    if (data.type === 'STATE') {
                        gameState = data.payload;
                        clientLocalPlayer = gameState.players.find(p => p.id === 'client');
                        updateHUD();
                    }
                }
            });

            if(!isHost) loop(); // Cliente inicia loop de renderizado
        }

        function handleClientInput(data) {
            // El host actualiza al jugador "client" (índice 1 en array players)
            const p = gameState.players[1];
            if (!p || !p.alive) return;

            // Movimiento basado en teclas del cliente
            let speed = data.keys.shift ? CONFIG.runSpeed : CONFIG.walkSpeed;
            if (data.keys.w) moveEntity(p, 0, -speed);
            if (data.keys.s) moveEntity(p, 0, speed);
            if (data.keys.a) moveEntity(p, -speed, 0);
            if (data.keys.d) moveEntity(p, speed, 0);
            
            p.angle = data.mouse.angle;
            p.currentWeapon = data.weaponIdx;

            // Disparo
            if (data.mouse.down) tryShoot(p);
        }

        function resetMenu() {
            // Recargar página simple para resetear todo
            location.reload();
        }

        function copyToClipboard() {
            const text = document.getElementById('my-peer-id').innerText;
            navigator.clipboard.writeText(text);
            alert("ID copiado al portapapeles");
        }

        // === LÓGICA DEL JUEGO (HOST) ===
        function initGame() {
            gameState.active = true;
            initMap();
            startRound();
            loop();
            
            // Timer del servidor
            setInterval(() => {
                if(gameState.active && gameState.timer > 0) gameState.timer--;
                if(gameState.timer <= 0) endRound('timeout');
            }, 1000);
        }

        function initMap() {
            // Definir paredes (Mapa estilo almacén)
            gameState.walls = [
                // Bordes
                {x:0, y:0, w:1024, h:20}, {x:0, y:748, w:1024, h:20},
                {x:0, y:0, w:20, h:768}, {x:1004, y:0, w:20, h:768},
                // Obstáculos centrales
                {x:200, y:200, w:150, h:20}, {x:200, y:200, w:20, h:150},
                {x:650, y:500, w:200, h:20}, {x:830, y:400, w:20, h:120},
                // Cajas sueltas
                {x:450, y:350, w:60, h:60}, {x:550, y:150, w:40, h:100}
            ];
        }

        function startRound() {
            gameState.bullets = [];
            gameState.players = [];
            gameState.timer = CONFIG.roundTime;

            // 0: Host (Azul)
            gameState.players.push(new Player('host', 'blue', 100, 384, false));
            // 1: Cliente (Rojo)
            gameState.players.push(new Player('client', 'red', 900, 384, false));
            
            // Bots Azules
            gameState.players.push(new Player('bot_b1', 'blue', 80, 300, true));
            gameState.players.push(new Player('bot_b2', 'blue', 80, 460, true));
            
            // Bots Rojos
            gameState.players.push(new Player('bot_r1', 'red', 920, 300, true));
            gameState.players.push(new Player('bot_r2', 'red', 920, 460, true));
        }

        function updateHost() {
            if (!gameState.active) return;

            // 1. Procesar Input Local (Host)
            const hostPlayer = gameState.players[0];
            if (hostPlayer.alive) {
                let speed = input.keys.shift ? CONFIG.runSpeed : CONFIG.walkSpeed;
                if (input.keys.w) moveEntity(hostPlayer, 0, -speed);
                if (input.keys.s) moveEntity(hostPlayer, 0, speed);
                if (input.keys.a) moveEntity(hostPlayer, -speed, 0);
                if (input.keys.d) moveEntity(hostPlayer, speed, 0);
                
                // Calcular ángulo host
                const rect = canvas.getBoundingClientRect();
                hostPlayer.angle = Math.atan2(input.mouse.y, input.mouse.x);
                hostPlayer.currentWeapon = input.weaponIdx;
                
                if (input.mouse.down) tryShoot(hostPlayer);
            }

            // 2. Procesar Bots
            gameState.players.forEach(p => {
                if (p.isBot && p.alive) updateBotAI(p);
            });

            // 3. Procesar Balas
            gameState.bullets.forEach((b, i) => {
                b.x += b.vx;
                b.y += b.vy;
                
                // Colisión paredes
                let hitWall = checkWallCollision(b.x, b.y, 2);
                if (hitWall || b.x < 0 || b.x > CONFIG.width || b.y < 0 || b.y > CONFIG.height) {
                    gameState.bullets.splice(i, 1);
                    return;
                }

                // Colisión jugadores
                gameState.players.forEach(target => {
                    if (target.alive && target.team !== b.team) {
                        let dx = b.x - target.x;
                        let dy = b.y - target.y;
                        if (Math.sqrt(dx*dx + dy*dy) < 15) {
                            target.hp -= b.dmg;
                            gameState.bullets.splice(i, 1);
                            // Efecto sangre simple
                            gameState.effects.push({x: target.x, y: target.y, type:'blood', time: 20});
                            
                            if (target.hp <= 0) {
                                target.alive = false;
                                checkWinCondition();
                            }
                        }
                    }
                });
            });

            // 4. Limpiar efectos
            gameState.effects = gameState.effects.filter(e => e.time-- > 0);

            // 5. Enviar estado al cliente
            if (conn && conn.open) {
                conn.send({ type: 'STATE', payload: gameState });
            }
            
            updateHUD(); // Host HUD update
        }

        function updateBotAI(bot) {
            // IA Simplificada: Ir hacia el enemigo vivo más cercano
            const enemies = gameState.players.filter(p => p.team !== bot.team && p.alive);
            if (enemies.length === 0) return;

            const target = enemies.reduce((prev, curr) => {
                let d1 = Math.hypot(prev.x - bot.x, prev.y - bot.y);
                let d2 = Math.hypot(curr.x - bot.x, curr.y - bot.y);
                return d1 < d2 ? prev : curr;
            });

            const dx = target.x - bot.x;
            const dy = target.y - bot.y;
            const dist = Math.hypot(dx, dy);
            const angle = Math.atan2(dy, dx);

            bot.angle = angle;

            // Moverse si está lejos
            if (dist > 200) {
                moveEntity(bot, Math.cos(angle) * 2, Math.sin(angle) * 2);
            }

            // Disparar si tiene línea de visión (raycast simple)
            if (dist < 400 && Math.random() < 0.05) {
                tryShoot(bot);
            }
        }

        function moveEntity(entity, dx, dy) {
            const newX = entity.x + dx;
            const newY = entity.y + dy;
            
            // Chequeo simple de colisión con paredes
            if (!checkWallCollision(newX, entity.y, 10)) entity.x = newX;
            if (!checkWallCollision(entity.x, newY, 10)) entity.y = newY;
        }

        function checkWallCollision(x, y, radius) {
            return gameState.walls.some(w => 
                x + radius > w.x && x - radius < w.x + w.w &&
                y + radius > w.y && y - radius < w.y + w.h
            );
        }

        function tryShoot(player) {
            // Verificar desbloqueo de arma (Subfusil ronda 4+)
            if (player.currentWeapon === 0 && gameState.round < 4) return;
            
            const weapon = player.weapons[player.currentWeapon];
            const now = Date.now();

            if (now - player.lastShot < weapon.delay) return;
            if (weapon.ammo !== null && player.ammo <= 0) return;

            player.lastShot = now;
            if (weapon.ammo !== null) player.ammo--;

            if (weapon.name === 'Karambit') {
                // Lógica Melee
            } else {
                // Disparo
                let spread = (Math.random() - 0.5) * 0.1; // Un poco de dispersión
                gameState.bullets.push({
                    x: player.x, y: player.y,
                    vx: Math.cos(player.angle + spread) * 15,
                    vy: Math.sin(player.angle + spread) * 15,
                    dmg: weapon.dmg,
                    team: player.team
                });
            }
        }

        function checkWinCondition() {
            const blueAlive = gameState.players.filter(p => p.team === 'blue' && p.alive).length;
            const redAlive = gameState.players.filter(p => p.team === 'red' && p.alive).length;

            if (blueAlive === 0) endRound('red');
            else if (redAlive === 0) endRound('blue');
        }

        function endRound(winner) {
            if (!gameState.active) return;
            gameState.active = false;
            
            if (winner === 'blue') gameState.score.blue++;
            else if (winner === 'red') gameState.score.red++;
            
            if (gameState.score.blue >= 7 || gameState.score.red >= 7) {
                setTimeout(() => {
                    document.getElementById('end-screen').classList.remove('hidden');
                    document.getElementById('winner-text').innerText = (gameState.score.blue >= 7 ? "EQUIPO AZUL" : "EQUIPO ROJO") + " GANA";
                }, 1000);
            } else {
                gameState.round++;
                setTimeout(() => {
                    gameState.active = true;
                    startRound();
                }, 3000);
            }
        }

        // === RENDERIZADO ===
        function draw() {
            // 1. Fondo (Suelo con grilla)
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dibujar grilla
            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let x=0; x<canvas.width; x+=40) { ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); }
            for(let y=0; y<canvas.height; y+=40) { ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); }
            ctx.stroke();

            // 2. Elementos del juego (Entidades)
            // Solo dibujamos los cuerpos muertos primero (debajo de vivos)
            gameState.players.forEach(p => {
                if (!p.alive) drawPlayer(p);
            });
            gameState.players.forEach(p => {
                if (p.alive) drawPlayer(p);
            });

            // 3. Balas
            ctx.fillStyle = '#ffeba7';
            gameState.bullets.forEach(b => {
                ctx.beginPath(); ctx.arc(b.x, b.y, 3, 0, Math.PI*2); ctx.fill();
            });

            // 4. Paredes (Estilo 2.5D simple)
            ctx.fillStyle = '#444'; // Top
            ctx.shadowColor = 'black';
            ctx.shadowBlur = 10;
            gameState.walls.forEach(w => {
                ctx.fillRect(w.x, w.y, w.w, w.h);
                // Borde decorativo
                ctx.strokeStyle = '#666';
                ctx.strokeRect(w.x, w.y, w.w, w.h);
            });
            ctx.shadowBlur = 0;

            // 5. SISTEMA DE ILUMINACIÓN Y VISIÓN
            const myPlayer = isHost ? gameState.players[0] : clientLocalPlayer;
            if (myPlayer && myPlayer.alive) {
                renderLighting(myPlayer);
            } else if (!myPlayer) {
                // Espectador
            }
        }

        function drawPlayer(p) {
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.angle);
            
            if (!p.alive) {
                ctx.globalAlpha = 0.4; // Cadáver
                ctx.fillStyle = '#333';
                ctx.beginPath(); ctx.arc(0,0, 12, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = '#500'; // Sangre
                ctx.stroke();
            } else {
                // Cuerpo
                ctx.fillStyle = p.team === 'blue' ? '#0055ff' : '#ff3333';
                ctx.beginPath(); ctx.arc(0, 0, 14, 0, Math.PI*2); ctx.fill();
                // Hombros/Chaleco
                ctx.fillStyle = '#222';
                ctx.fillRect(-10, -10, 20, 20);
                // Cabeza (casco)
                ctx.fillStyle = p.team === 'blue' ? '#4facfe' : '#ff5858';
                ctx.beginPath(); ctx.arc(0, 0, 9, 0, Math.PI*2); ctx.fill();
                // Brazos/Arma
                ctx.fillStyle = '#eee';
                ctx.fillRect(5, 2, 18, 4); 
            }
            ctx.restore();
        }

        function renderLighting(player) {
            // Creamos una capa oscura sobre todo el mapa
            // Usamos destination-out para "borrar" la oscuridad donde miramos
            
            // 1. Guardar estado actual
            ctx.save();
            
            // 2. Crear oscuridad (Niebla de guerra)
            // No es negro total, para que se intuya el mapa muy levemente (opcional), 
            // pero el usuario pidió "luz transparente", así que usaremos oscuridad densa.
            ctx.fillStyle = 'rgba(0, 0, 0, 0.96)'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 3. Configurar modo de recorte
            ctx.globalCompositeOperation = 'destination-out';

            // 4. Dibujar cono de luz
            const radius = 400;
            const fov = Math.PI / 3; // 60 grados
            
            // Creamos un gradiente radial para que la luz se desvanezca suavemente (transparencia en los bordes)
            const gradient = ctx.createRadialGradient(player.x, player.y, 50, player.x, player.y, radius);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');   // Centro corta totalmente la oscuridad
            gradient.addColorStop(0.8, 'rgba(255, 255, 255, 0.5)'); // Borde empieza a ser oscuro
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');   // Final es oscuro

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(player.x, player.y);
            ctx.arc(player.x, player.y, radius, player.angle - fov/2, player.angle + fov/2);
            ctx.lineTo(player.x, player.y);
            ctx.fill();

            // Restaurar para volver a pintar normal
            ctx.restore();

            // 5. Dibujar la "Luz" en sí (el haz brillante transparente encima)
            ctx.save();
            ctx.globalCompositeOperation = 'overlay'; // Modo de fusión para aclarar el suelo
            const lightGrad = ctx.createRadialGradient(player.x, player.y, 0, player.x, player.y, radius);
            lightGrad.addColorStop(0, 'rgba(255, 255, 200, 0.15)'); // Luz cálida muy tenue
            lightGrad.addColorStop(1, 'rgba(0,0,0,0)');
            
            ctx.fillStyle = lightGrad;
            ctx.beginPath();
            ctx.moveTo(player.x, player.y);
            ctx.arc(player.x, player.y, radius, player.angle - fov/2, player.angle + fov/2);
            ctx.fill();
            ctx.restore();
        }

        function updateHUD() {
            const myPlayer = isHost ? gameState.players[0] : clientLocalPlayer;
            
            // Scores
            document.getElementById('score-blue').innerText = gameState.score.blue;
            document.getElementById('score-red').innerText = gameState.score.red;
            
            // Timer
            let m = Math.floor(gameState.timer / 60);
            let s = gameState.timer % 60;
            document.getElementById('timer').innerText = `${m}:${s<10?'0'+s:s}`;

            // Weapon
            if (myPlayer) {
                const w = myPlayer.weapons[myPlayer.currentWeapon];
                document.getElementById('weapon-name').innerText = w.name;
                document.getElementById('ammo-count').innerText = w.ammo === null ? '∞' : `${myPlayer.ammo} / ∞`;
            }
        }

        // === LOOP PRINCIPAL ===
        function loop() {
            if (isHost) updateHost();
            else if (conn && conn.open) {
                // El cliente solo envía inputs y renderiza
                const rect = canvas.getBoundingClientRect();
                const mouseAngle = Math.atan2(input.mouse.y, input.mouse.x);
                conn.send({
                    type: 'INPUT',
                    payload: {
                        keys: input.keys,
                        mouse: { angle: mouseAngle, down: input.mouse.down },
                        weaponIdx: input.weaponIdx
                    }
                });
            }

            draw();
            requestAnimationFrame(loop);
        }

        // === EVENT LISTENERS ===
        window.addEventListener('keydown', e => {
            const key = e.key.toLowerCase();
            if (key in input.keys) input.keys[key] = true;
            if (key === 'shift') input.keys.shift = true;
            
            // Cambio armas
            if (key === '1') input.weaponIdx = 0;
            if (key === '2') input.weaponIdx = 1;
            if (key === '3') input.weaponIdx = 2;
        });
        
        window.addEventListener('keyup', e => {
            const key = e.key.toLowerCase();
            if (key in input.keys) input.keys[key] = false;
            if (key === 'shift') input.keys.shift = false;
        });

        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            input.mouse.x = e.clientX - rect.left;
            input.mouse.y = e.clientY - rect.top;
        });
        
        canvas.addEventListener('mousedown', () => input.mouse.down = true);
        canvas.addEventListener('mouseup', () => input.mouse.down = false);

    </script>
</body>
</html>
